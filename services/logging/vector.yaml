# Ingests GELF logs from Docker daemon and forwards to Loki and Graylog (both over TCP)

sources:
  # Receive GELF messages from Docker containers via UDP
  docker_gelf:
    type: socket
    address: "0.0.0.0:12201"
    mode: udp
    decoding:
      codec: gelf
    framing:
      method: chunked_gelf
      # Auto-detect compression (gzip, zlib, or uncompressed)
      decompression: Auto

transforms:
  # Process and enrich the logs
  process_logs:
    type: remap
    inputs: ["docker_gelf"]
    source: |
      # Make sure to retain .host from the GELF message (originating host), do not overwrite
      # Map short_message to message for Loki compatibility
      if exists(.short_message) {
        .message = .short_message
      }

      # Extract structured log fields from message using regex pattern
      if exists(.message) {
        # python service logs
        parsed_fields, err = parse_regex(.message, r'log_level=(?P<log_level>[^|]*) \| log_timestamp=(?P<log_timestamp>[^|]*) \| log_source=(?P<log_source>[^|]*) \| log_uid=(?P<log_uid>[^|]*) \| log_oec=(?P<log_oec>[^|]*) \| log_trace_id=(?P<log_trace_id>[^|]*) \| log_span_id=(?P<log_span_id>[^|]*) \| log_msg=(?P<log_msg>.*)$')
        # traefik logs
        traefik_fields, traefik_err = parse_regex(.message, r'time="(?P<log_timestamp>[^"]*)" level=(?P<log_level>\w+) msg="(?P<log_msg>.*)"')
        if err == null {
          .log_level = parsed_fields.log_level
          .log_timestamp = parsed_fields.log_timestamp
          .log_source = parsed_fields.log_source
          .log_uid = parsed_fields.log_uid
          .log_oec = parsed_fields.log_oec
          .log_trace_id = parsed_fields.log_trace_id
          .log_span_id = parsed_fields.log_span_id
          .log_msg = parsed_fields.log_msg
        } else if traefik_err == null {
          .log_timestamp = traefik_fields.log_timestamp
          .log_level = traefik_fields.log_level
          .log_msg = traefik_fields.log_msg
        } else {
          .log_msg = .message
        }

        log_msg_processed = replace!(.log_msg, "\\n", "
        ")
        if log_msg_processed != null {
          .log_msg = log_msg_processed
        }
      }

      # ensure level is set for Grafana/Loki to color the log correctly
      if exists(.log_level){
        .level = .log_level
      } else {
        .level = "UNKNOWN"
      }

      # Handle container name - GELF uses _container_name (with underscore prefix)
      if exists(._container_name) {
        .container_name = ._container_name

        # Extract Docker service name from container name (everything before first dot)
        match = parse_regex!(.container_name, r'^(?P<service_name>[^.]+)')
        .service_name = match.service_name
      } else {
        .container_name = "unknown"
        .service_name = "unknown"
      }
      .log_service = .service_name

      # Handle container ID
      if exists(._container_id) {
        .container_id = ._container_id
      } else {
        .container_id = "unknown"
      }

      # Handle image name
      if exists(._image_name) {
        .image_name = ._image_name
      } else {
        .image_name = "unknown"
      }

      # Add processing metadata
      .processed_by = "vector"

sinks:
  # Send to Loki over TCP
  loki:
    type: loki
    inputs: ["process_logs"]
    endpoint: "http://${VECTOR_LOG_DESTINATION:?err}:12204"
    encoding:
      codec: json
    labels:
      source: "vector"
      host: "{{ host }}"
      container_name: "{{ container_name }}"
      service_name: "{{ service_name }}"

    healthcheck:
      enabled: true

  # Send to Graylog via GELF over TCP
  graylog:
    type: socket
    inputs: ["process_logs"]
    address: "${VECTOR_LOG_DESTINATION:?err}:12203"
    mode: tcp
    encoding:
      codec: gelf
    healthcheck:
      enabled: true


  # Temporary: Output to console for debugging
  #console_debug:
  #  type: console
  #  inputs: ["process_logs"]
  #  encoding:
  #    codec: json

# Global configuration
api:
  enabled: true
  address: "0.0.0.0:8686"

data_dir: "/var/lib/vector"
