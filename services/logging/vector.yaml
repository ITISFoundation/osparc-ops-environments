# Ingests GELF logs from Docker daemon and forwards to Loki and Graylog (both over TCP)

sources:
  # Receive GELF messages from Docker containers via UDP
  docker_gelf:
    type: socket
    address: "0.0.0.0:12201"
    mode: udp
    decoding:
      codec: gelf
    framing:
      method: chunked_gelf
      # Auto-detect compression (gzip, zlib, or uncompressed)
      decompression: Auto

transforms:
  # Process and enrich the logs
  process_logs:
    type: remap
    inputs: ["docker_gelf"]
    source: |
      # Make sure to retain .host from the GELF message (originating host), do not overwrite
      # Map short_message to message for Loki compatibility
      if exists(.short_message) {
        .message = .short_message
      }

      # Extract structured log fields from message using regex pattern
      if exists(.message) {
        parsed_fields, err = parse_regex(.message, r'log_level=(?P<log_level>[^|]*) \| log_timestamp=(?P<log_timestamp>[^|]*) \| log_source=(?P<log_source>[^|]*) \| log_uid=(?P<log_uid>[^|]*) \| log_oec=(?P<log_oec>[^|]*) \| log_trace_id=(?P<log_trace_id>[^|]*) \| log_span_id=(?P<log_span_id>[^|]*) \| log_msg=(?P<log_msg>.*)$')
        if err == null {
          .log_level = parsed_fields.log_level
          .log_timestamp = parsed_fields.log_timestamp
          .log_source = parsed_fields.log_source
          .log_uid = parsed_fields.log_uid
          .log_oec = parsed_fields.log_oec
          .log_trace_id = parsed_fields.log_trace_id
          .log_span_id = parsed_fields.log_span_id
          .log_msg = parsed_fields.log_msg
        }
      }

      # Handle container name - GELF uses _container_name (with underscore prefix)
      if exists(._container_name) {
        .container_name = ._container_name
        
        # Extract Docker service name from container name (everything before first dot)
        service_parts = split(.container_name, ".")
        if length(service_parts) > 0 {
          .service_name = service_parts[0]
        } else {
          .service_name = .container_name
        }
      } else {
        .container_name = "unknown"
        .service_name = "unknown"
      }

      # Handle container ID
      if exists(._container_id) {
        .container_id = ._container_id
      } else {
        .container_id = "unknown"
      }

      # Handle image name
      if exists(._image_name) {
        .image_name = ._image_name
      } else {
        .image_name = "unknown"
      }

      # Add processing metadata
      .processed_by = "vector"

sinks:
  # Send to Loki over TCP
  loki:
    type: loki
    inputs: ["process_logs"]
    endpoint: "http://${VECTOR_LOG_DESTINATION:?err}:12204"
    encoding:
      codec: json
    labels:
      host: "{{ host }}"
      container_name: "{{ container_name }}"
      service_name: "{{ service_name }}"
      # Override level label with extracted log_level from structured logs. This ensures correct color coding in Loki/Grafana
      level: "{{ log_level }}"

    # Remove label fields from the log line to avoid duplication
    remove_label_fields: true
    healthcheck:
      enabled: true

  # Send to Graylog via GELF over TCP
  graylog:
    type: socket
    inputs: ["process_logs"]
    address: "${VECTOR_LOG_DESTINATION:?err}:12203"
    mode: tcp
    encoding:
      codec: gelf
    healthcheck:
      enabled: true

  # Temporary: Output to console for debugging
  #console_debug:
  #  type: console
  #  inputs: ["process_logs"]
  #  encoding:
  #    codec: json

# Global configuration
api:
  enabled: true
  address: "0.0.0.0:8686"

data_dir: "/var/lib/vector"
