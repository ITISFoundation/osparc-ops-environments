services:
  traefik:
    image: "traefik:v3.4.0"
    init: true
    command:
      - "--api=true"
      - "--ping=true"
      - "--entryPoints.ping.address=:9082"
      - "--ping.entryPoint=ping"
      - "--api.dashboard=true"
      - "--accesslog=true"
      - "--accesslog.format=json"
      - "--accesslog.fields.defaultmode=keep"
      - "--accesslog.fields.names.ClientUsername=keep"
      - "--accesslog.fields.headers.defaultmode=keep"
      - "--accesslog.fields.headers.names.User-Agent=keep"
      - "--accesslog.fields.headers.names.Authorization=drop"
      - "--accesslog.fields.headers.names.Content-Type=keep"
      - "--log.level=${OPS_TRAEFIK_LOGLEVEL}"
      - "--metrics.prometheus=true"
      - "--metrics.prometheus.addEntryPointsLabels=true"
      - "--metrics.prometheus.addServicesLabels=true"
      - "--entryPoints.metrics.address=:8082"
      - "--metrics.prometheus.entryPoint=metrics"
      - "--entryPoints.http.address=:80"
      - "--entryPoints.http.transport.respondingTimeouts.writeTimeout=21600s" #6h, for https://github.com/traefik/traefik/issues/10805
      - "--entryPoints.http.transport.respondingTimeouts.readTimeout=21600s" #6h, for https://github.com/traefik/traefik/issues/10805
      - "--entrypoints.http.http.redirections.entrypoint.to=https"
      - "--entrypoints.http.http.redirections.entrypoint.scheme=https"
      - "--entrypoints.http.http.redirections.entrypoint.permanent=true"
      - '--entryPoints.postgres.address=:5432'
      - '--entryPoints.postgres2.address=:5433'
      - "--entryPoints.https.address=:443"
      - "--entryPoints.https.transport.respondingTimeouts.writeTimeout=21600s" #6h, for https://github.com/traefik/traefik/issues/10805
      - "--entryPoints.https.transport.respondingTimeouts.readTimeout=21600s" #6h, for https://github.com/traefik/traefik/issues/10805
      - "--providers.swarm.endpoint=unix:///var/run/docker.sock"
      - "--providers.swarm.exposedByDefault=false"
      # so that internal services are not picked up
      - "--providers.swarm.constraints=!LabelRegex(`io.simcore.zone`, `${TRAEFIK_SIMCORE_ZONE}`)"
      - "--core.defaultRuleSyntax=v2"
      - "--tracing=true"
      - "--tracing.addinternals"
      - "--tracing.otlp=true"
      - "--tracing.otlp.http=true"
    healthcheck:
      # NOTE: this healthcheck to check if traefik is up and running must be run on the ping entrypoint defined in command!
      test: traefik healthcheck --ping --ping.entryPoint=ping --entryPoints.ping.address=:9082
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
      start_interval: 1s
    ports:
      - target: 80
        published: 80
        mode: host
      - target: 443
        published: 443
        mode: host
      - target: 5432
        published: 5432
        mode: host
      - target: 5433
        published: 5433
        mode: host
    configs:
      - source: traefik_dynamic_config.yml
        target: /etc/traefik/dynamic_conf.yml
    volumes:
      # So that Traefik can listen to the Docker events
      - /var/run/docker.sock:/var/run/docker.sock
    deploy:
      # mode: global
      replicas: ${OPS_TRAEFIK_REPLICAS}
      update_config:
        order: stop-first
        delay: 20s
        failure_action: rollback
        parallelism: 1
      resources:
        limits:
          memory: 2048M
          cpus: '3.000'
        reservations:
          memory: 500M
          cpus: '1.000'
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.swarm.network=${PUBLIC_NETWORK}
        # ssl header necessary so that socket.io upgrades correctly from polling to websocket mode. the middleware must be attached to the right connection.
        - traefik.http.middlewares.ops_sslheader.headers.customrequestheaders.X-Forwarded-Proto=https
        ####### SECURITY HEADERS --> See https://infosec.mozilla.org/guidelines/web_security
        # Content Security Policy
        - >
                traefik.http.middlewares.ops_sslheader.headers.contentSecurityPolicy=frame-ancestors https://*.${MACHINE_FQDN}:* 'self'; default-src 'self'{% for j2item in DEPLOYMENT_FQDNS.replace("\"","").replace('\'',"").replace(" ","").split(",") %}{{" *." + j2item + " " + j2item if j2item else ""}}{% endfor %}; script-src https: 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src *;

        # Strict Transport Security
        - traefik.http.middlewares.ops_sslheader.headers.stsSeconds=15768001
        #- traefik.http.middlewares.ops_sslheader.headers.stsPreload=true
        - traefik.http.middlewares.ops_sslheader.headers.stsIncludeSubdomains=true
        # X-Content-Type-Options header with the value nosniff: DOESNT WORK WITH OSPARC
        #- traefik.http.middlewares.ops_sslheader.headers.contentTypeNosniff=true
        # X-Frame-Options - Enabling this breaks osparc
        #- traefik.http.middlewares.ops_sslheader.headers.customFrameOptionsValue=DENY
        # X-XSS-Protecton
        - traefik.http.middlewares.ops_sslheader.headers.browserxssfilter=true

        ###########################
        # via https://community.traefik.io/t/v2-2-8-global-redirect-www-to-non-www-with-http-to-https/7428
        # see also: https://community.traefik.io/t/get-a-valid-ssl-certificate-for-www-domains-via-traefik-and-lets-encrypt/2023
        # Global redirection: https (www.) to https
        # why .strip("\"'") ? --> https://github.com/kolypto/j2cli/issues/77
        - traefik.http.routers.www-catchall.rule={{ DEPLOYMENT_FQDNS_WWW_CAPTURE_TRAEFIK_RULE.strip("\"'") }}
        - traefik.http.routers.www-catchall.priority=100000
        - traefik.http.routers.www-catchall.entrypoints=https,http
        - traefik.http.routers.www-catchall.tls=true
        - traefik.http.routers.www-catchall.middlewares=strip-www

        ###########################
        # basic authentication
        # Note: all dollar signs in the hash need to be doubled for escaping.
        # To create user:password pair, it's possible to use this command:
        # docker run --rm --entrypoint htpasswd registry:2 -nb user password | sed -e s/\\$/\\$\\$/g
        # echo $(htpasswd -nb user password) | sed -e s/\\$/\\$\\$/g
        - traefik.http.middlewares.ops_auth.basicauth.users=${TRAEFIK_USER}:${TRAEFIK_PASSWORD}
        # gzip compression
        - traefik.http.middlewares.ops_gzip.compress=true
        # ip whitelisting
        - traefik.http.middlewares.ops_whitelist_ips.ipallowlist.sourcerange=${TRAEFIK_IPWHITELIST_SOURCERANGE}
        # traefik UI
        - traefik.http.routers.api.service=api@internal
        - traefik.http.routers.api.rule=Host(`${MONITORING_DOMAIN}`) &&
          (PathPrefix(`/dashboard`) || PathPrefix(`/api`))
        - traefik.http.routers.api.entrypoints=https
        - traefik.http.routers.api.tls=true
        - traefik.http.routers.api.middlewares=ops_whitelist_ips@swarm,
          ops_auth@swarm, ops_gzip@swarm
        - traefik.http.services.api.loadbalancer.server.port=8080
        # prometheus labels
        - prometheus-job=traefik_ops
        - prometheus-port=8082
        # wildcard certificate
        - traefik.http.routers.api.tls.domains[0].main=service.${MACHINE_FQDN}
        - traefik.http.routers.api.tls.domains[0].sans=*.services.${MACHINE_FQDN}
        - traefik.http.routers.api.tls.domains[0].main=service.testing.${MACHINE_FQDN}
        - traefik.http.routers.api.tls.domains[0].sans=*.services.testing.${MACHINE_FQDN}
        # ops generic rate limiter
        - traefik.http.middlewares.ops_ratelimit.ratelimit.average=${TRAEFIK_RATELIMIT_AVG}
        - traefik.http.middlewares.ops_ratelimit.ratelimit.burst=${TRAEFIK_RATELIMIT_BURST}
        - traefik.http.middlewares.ops_ratelimit.ratelimit.sourcecriterion.ipstrategy.depth=1
        # Platform user auth: Use this middleware to enforce only authenticated users
        # https://doc.traefik.io/traefik/middlewares/http/forwardauth
        - traefik.http.middlewares.authenticated_platform_user.forwardauth.address=http://${WEBSERVER_HOST}:${WEBSERVER_PORT}/v0/auth:check
        - traefik.http.middlewares.authenticated_platform_user.forwardauth.trustForwardHeader=true
        - traefik.http.middlewares.authenticated_platform_user.forwardauth.authResponseHeaders=Set-Cookie,osparc-sc2
        #
        # middleware: http(s)://(www.) to  https://
        - traefik.http.middlewares.strip-www.redirectregex.regex=^(https?)://www\.(.+)
        - traefik.http.middlewares.strip-www.redirectregex.replacement=$${1}://$${2}
        - traefik.http.middlewares.strip-www.redirectregex.permanent=true


        ###
        # Domain redirects
        ###
{% set redirect_from_domains_list = TRAEFIK_DOMAINS_REDIRECT_FROM.strip().split(',') if TRAEFIK_DOMAINS_REDIRECT_FROM.strip() else [] %}
{% set redirect_to_domains_list = TRAEFIK_DOMAINS_REDIRECT_TO.strip().split(',') if TRAEFIK_DOMAINS_REDIRECT_TO.strip() else [] %}
{% set redirect_is_permanent_list = TRAEFIK_DOMAINS_REDIRECT_IS_PERMANENT.strip().split(',') if TRAEFIK_DOMAINS_REDIRECT_IS_PERMANENT.strip() else [] %}

{% for ix in range(redirect_from_domains_list | length) %}

{% set from_domain = redirect_from_domains_list[ix] %}
{% set from_domain_no_dots = from_domain.replace(".", "-") %}
{% set to_domain = redirect_to_domains_list[ix] %}
{% set redirect_is_permanent = redirect_is_permanent_list[ix] %}

        # Regex below is redirecting any subdomains and path to new domain.
        #     Use https://regex101.com/r/58sIgx/2 for regex explanation and experimentation.
        #     Below we include dollar escaping and j2 expressions. It is not clean / pure regex
        #     You can fetch baked and clean regex from traefik dashboards.
        - traefik.http.middlewares.redirect-{{ from_domain_no_dots }}.redirectregex.regex=^https?://((?:[a-zA-Z0-9-]+\.)*)*{{ from_domain }}(.*)$$
        - traefik.http.middlewares.redirect-{{ from_domain_no_dots }}.redirectregex.replacement=https://$${1}{{ to_domain }}$${2}
        - traefik.http.middlewares.redirect-{{ from_domain_no_dots }}.redirectregex.permanent={{ redirect_is_permanent }}
        - traefik.http.routers.{{ from_domain_no_dots }}.rule={{ generate_domain_capture_all_rule(from_domain) }}
        - traefik.http.routers.{{ from_domain_no_dots }}.middlewares=redirect-{{ from_domain_no_dots }}
        - traefik.http.routers.{{ from_domain_no_dots }}.entrypoints=https
        - traefik.http.routers.{{ from_domain_no_dots }}.tls=true

{% endfor %}

    networks:
      public: null
      monitored: null

  whoami:
    image: "containous/whoami"
    deploy:
      placement:
        constraints:
          - node.labels.traefik==true
      labels:
        - traefik.enable=true
        - traefik.swarm.network=${PUBLIC_NETWORK}
        - traefik.http.services.whoami.loadbalancer.server.port=80
        - traefik.http.routers.whoami.rule=Host(`${MONITORING_DOMAIN}`) &&
          PathPrefix(`/whoami`)
        - traefik.http.routers.whoami.entrypoints=https
        - traefik.http.routers.whoami.tls=true
        - traefik.http.routers.whoami.middlewares=ops_whitelist_ips@swarm,
          ops_auth@swarm, ops_gzip@swarm
      resources:
        limits:
          memory: 50M
          cpus: '0.5'
        reservations:
          memory: 6M
          cpus: '0.1'
    networks:
      - public

  error-pages-static-webserver:
    image: nginx:1.25.1
    networks:
      - public
    configs:
      - source: ${STACK_NAME}_503_api_json
        target: /usr/share/nginx/api/503.json
      - source: ${STACK_NAME}_503_web_html
        target: /usr/share/nginx/html/503.html
      - source: ${STACK_NAME}_nginx_error_pages_config
        target: /etc/nginx/conf.d/default.conf
    deploy:
      labels:
        # defining labels as list has advantage in interpolation
        # https://docs.docker.com/reference/compose-file/interpolation/
        # disadvantage: we cannot reuse values with yaml `& and *` syntax
        - traefik.enable=true

        # middleware for ops traefik. Use for custom 503 (json) api response
        - traefik.http.middlewares.custom-50x-json-errors.errors.status=500,501,503,505-599
        - traefik.http.middlewares.custom-50x-json-errors.errors.service=traefik_error_page_json
        - traefik.http.middlewares.custom-50x-json-errors.errors.query=/503.json

        # middleware for ops traefik. Use for custom 503 html response
        - traefik.http.middlewares.custom-50x-html-errors.errors.status=500,501,503,505-599
        - traefik.http.middlewares.custom-50x-html-errors.errors.service=traefik_error_page_html
        - traefik.http.middlewares.custom-50x-html-errors.errors.query=/503.json

        # rule to serve custom 503 error html page
        - traefik.http.routers.traefik_error_page_html.entrypoints=http
        - traefik.http.routers.traefik_error_page_html.priority=1
        - traefik.http.routers.traefik_error_page_html.rule=Path(`/503.html`)
        - traefik.http.routers.traefik_error_page_html.tls=false
        - traefik.http.routers.traefik_error_page_html.service=traefik_error_page_html
        - traefik.http.services.traefik_error_page_html.loadbalancer.server.port=80 # nginx port for (non-api) http

        # rule to serve custom 503 error json page
        - traefik.http.routers.traefik_error_page_json.entrypoints=http
        - traefik.http.routers.traefik_error_page_json.priority=1
        - traefik.http.routers.traefik_error_page_json.rule=Path(`/503.json`)
        - traefik.http.routers.traefik_error_page_json.tls=false
        - traefik.http.routers.traefik_error_page_json.service=traefik_error_page_json
        - traefik.http.services.traefik_error_page_json.loadbalancer.server.port=8000 # nginx port for (non-api) http

configs:
  traefik_dynamic_config.yml:
    name: {{ STACK_NAME }}_traefik_dynamic_config_{{ "./traefik_dynamic_config.yml" | sha256file | substring(0,10) }}
    file: ./traefik_dynamic_config.yml
  {{ STACK_NAME }}_503_web_html:
    file: ./config/error_pages/503.html
    name: {{ STACK_NAME }}_web_html_{{ "./config/error_pages/503.html" | sha256file | substring(0,10) }}
  {{ STACK_NAME }}_503_api_json:
    file: ./config/error_pages/503.json
    name: {{ STACK_NAME }}_api_json_{{ "./config/error_pages/503.json" | sha256file | substring(0,10) }}
  {{ STACK_NAME }}_nginx_error_pages_config:
    file: ./config/error_pages/default.conf
    name: {{ STACK_NAME }}_web_nginx_config_{{ "./config/error_pages/default.conf" | sha256file | substring(0,10) }}

networks:
  public:
    external: true
    name: ${PUBLIC_NETWORK}
  monitored:
    name: ${MONITORED_NETWORK}
    external: true
